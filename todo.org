* Préparation des cours et des TPs
** Semaine du 21/09/2015
*** TODO S'inscrire sur la liste de diffusion du cours.
** Semaine du 28/09/2015
*** TODO Avant le TP : Lire la documentation d'ocamllex et menhir.
*** TODO Lire marthe.ml

* Cours du <2016-02-10>
** TODO Introduire hobix
** TODO Compilation naïve
* Cours du <2016-02-17>
** DONE La beauté des monades, encore une fois.
** DONE Compilation avec arbres de décision
*** Prendre l'exemple de merge.

    type t = P of int * int

    let rec merge xs ys = match (xs, ys) with
    | [], _ -> .. 
    | _, [] -> ..
    | x :: xs, y :: ys -> ...            

    A =
    ([]           _     -> 1)
    (_            []    -> 2)
    ("_ :: (_ :: _)"  "_ :: _"  -> 3)

    S([], A) =
    (_  -> 1)

    S(::, A) =
    (_ _     []    -> 2)
    (_ (_ :: _)   _ :: _  -> 3)

    D(A) =
    ()

    C(xs ys, A) =
    Switch (xs, [] : A₀; "::" : A₁)

    A₀ = C(ys, S([], A)) = C(ys, (_ -> 1)) =
    Leaf 1

    A₁ = C(xs.0 xs.1 ys, ((_ _   []    -> 2) (_ _ _ :: _  -> 3))) =
    A₁ = Swap₃ (C(ys xs.0 xs.1, (([] _ _    -> 2) (_ :: _ _ _   -> 3))) =
    A₁ = Swap₃ (Switch (ys, [] : Leaf 2; "::" : Leaf 3))

    Switch (xs,
            [] : Leaf 1,
            "::" : Swap3 (Switch (ys, [] : Leaf 2, "::" : Leaf 3))

*** Les pattern-matchings comme des matrices de patterns.
*** Matrice spécialisée S(K, A) et matrice des résidus D(A)
*** Arbres de décision:
      T ::= Leaf k | Fail | Switch (o, cs) | Swap i
      cs := K₁ : T₁ ; ... ; Kₙ : Tₙ ; (default : T_d)?
*** Occurrences:
      o ::= x | o.n
*** Compilation vers les arbres de décisions

   C (o₁ ... oₙ, A)?

   C (o₁ ... oₙ, ∅) = Fail
   C (o₁ ... oₙ, ( ( _ ... _ ) ... )) = Leaf a1

   Sinon, il existe au moins une colonne qui contient
   un pattern qui n'est pas un wildcard. Soit i, le
   numéro d'une telle colonne.

   Supposons que i = 1: Calculer tous les constructeurs { c₁, .., cₖ }
   qui apparaissent dans la colonne i.

   Ensuite, pour chaque cₖ d'arité m:
   Aₖ = C (o₁ · 1 ... o₁ · m o₂ ⋯ oₙ, S (cₖ, A))

   Si les cₖ couvrent tous les cas possibles alors
   C (o₁ ... oₙ, A) = Switch (o₁, K₁ : A₁ … Kₖ : Aₖ)

   Si les cₖ ne couvrent pas tous les cas possibles alors
   A_D = C (o₂ ⋯ oₙ, D (A))
   C (o₁ ... oₙ, A) = Switch (o₁, K₁ : A₁ … Kₖ : Aₖ; default: A_D)

   Si i > 1, alors on permute les occurrences i et 1 (o') ainsi que
   les colonnes i et 1 de la matrice (A') puis:

   C (o₁ ... oₙ, A) = Swapᵢ (C (o', A'))

** DONE Compilation des fonctions de première classe
*** Rappel sur la notion de fermeture
Hobix:

val m :=
  val x := 1;
  \ y => x + y.

val z := m 42.

Fopix:

def f_code (env, y) = env[1] + y

val m =
  val x = 1;
  val b = alloc_block 2;
  b[0] = f_code;
  b[1] = x;
  b

val z =
  val f = alloc_read m 0;
  f (m, 42)

*** Les différents choix de représentation
*** Le langage fopix
*** La compilation par explicitation des fermetures
* Cours du <2016-02-24>
** DONE Répondre aux questions floues.
** DONE Fopix
** DONE Explicitation des fermetures unaires
** TODO Optimisations
** TODO Traitement des fermetures n-naires
* Cours du <2016-03-02>
** TODO Questions sur le jalon 4
*** Quelle est le rôle de la fonction pattern?
   Si on a :
   type t := { A : int | B }.

   expression << y ? { A x -> x | B -> 2 | _ -> 3 } >> =

   if read_block y 0 = 0 then
     val x = read_block y 1;
     x
   else if read_block y 0 = 1 then
     2
   else
     3

   pattern << y >> << A x >> =
   (<< read_block y 0 = 0 >>, [(x, << read_block y 1 >>])

   pattern << y >> << B >> =
   (<< read_block y 0 = 1 >>, [])

   if read_block x 0 = 0 then
     1
   else
     2

** TODO Questions sur l'explicitation des fermetures
*** Comment compiler les fonctions mutuellement récursives?

rec f x := g x
and g x := f x.

donne en Fopix:

def f x env := env[1][0] x env[1].
def g x env := env[1][0] x env[1].

val fc := allocate_block 2;
val gc := allocate_block 2;
write_block fc 0 &f;
write_block fc 1 gc;
write_block gc 0 &g;
write_block gc 1 fc.

** TODO Optimisations
*** Optimisation des appels internes
En Hopix:

rec fact n := if n = 0 then 1 else n * fact (n - 1) fi
val y := fact 2.

Si on la compile naivement:

def ffact n env =
  if n = 0 then
    1
  else
    n * env[1][0] (n - 1) env[1]
  fi

val fact :=
   val b := allocate_block 2;
   b[0] <- &ffact;
   b[1] <- b;
   b

val y := fact[0] 2 fact.

On veut plutôt la compiler comme suit:

def ffact n env =
  if n = 0 then
    1
  else
    n * ffact (n - 1) env
  fi

val fact :=
   val b := allocate_block 1;
   b[0] <- &ffact;
   b

val y := fact[0] 2 fact.

*** Reconnaître les appels à des fonctions connues

Dans l'exemple précédent, l'appel à la fonction fact est en fait un
FunCall et non un UnknownFunCall. En général, on peut écrire un
algorithme d'évaluation symbolique de programme qui s'assure qu'un
programme Fopix écrit en Hopix se compile en le même programme Fopix.

** TODO Traitement des fermetures n-naires

*** Le problème

val f := \x => \y => x + y.
val y := f 0 1.

est compilé en Fopix comme suit:

def f1 x env :=
  let b := allocate_block 2;
  b[0] <- &f2;
  b[1] <- x;
  b

def f2 y env :=
  env[1] + y

val f :=
  let b := allocate_block 1;
  b[0] <- &f1;
  b

val y :=
   let app1 := f[0] 0 f;
   app1[0] 1 app1

On aimerait plutôt compiler ce programme en:

def f1 x y env :=
  x + y

val f :=
  let b := allocate_block 4;
  b[0] <- &f1;
  b[1] <- 2
  b

val y :=
  f1 0 1 f 

Supposons qu'en Hopix, on ait l'application partielle suivante:

val g := f 0
val z := g 1

Elle sera compilée comme suit:

val g :=
  let b := copy f;
  f[1] <- 1;
  f[2] <- 0;
  b

val z :=
  generic_apply g [1]

où

generic_apply c [v1; ...; vN] =
  val M := c[1];
  if N = M then
    c[0] c[2] ... c[K] v1 ... vN c
  else if N < M then
    let b := copy c;
    b[1] <- M - N;
    b[K + 1] <- v1;
    ...
    b[K + N] <- vN;
    b
  else if N > M then
    val c' := c[0] c[2] ... c[K] v1 ... vM c;
    generic_apply c' [vM + 1; ..; VN]
  fi

** TODO Retrolix
*** Présentation de l'AST de Retrolix
*** Compilation de Fopix vers Retrolix
**** Compilation des expressions arithmétiques
val y := 42
val x := 3 * y + 42

y <- load 42
z <- mul 3 y
x <- add z 42
**** Compilation d'une conditionnelle

val y := if 1 < 0 then 0 else 1 fi

l_cond:
   jumpif less_than 1 0 -> l_then, l_else
l_then:
   y <- 0
   jump l_cont
l_else:
   y <- 1
   jump l_cont
l_cont:
   ...
