* Préparation des cours et des TPs
** Semaine du 21/09/2015
*** TODO S'inscrire sur la liste de diffusion du cours.
** Semaine du 28/09/2015
*** TODO Avant le TP : Lire la documentation d'ocamllex et menhir.
*** TODO Lire marthe.ml

* Cours du <2016-02-10>
** TODO Introduire hobix
** TODO Compilation naïve
* Cours du <2016-02-17>
** DONE La beauté des monades, encore une fois.
** DONE Compilation avec arbres de décision
*** Prendre l'exemple de merge.

    type t = P of int * int

    let rec merge xs ys = match (xs, ys) with
    | [], _ -> .. 
    | _, [] -> ..
    | x :: xs, y :: ys -> ...            

    A =
    ([]           _     -> 1)
    (_            []    -> 2)
    ("_ :: (_ :: _)"  "_ :: _"  -> 3)

    S([], A) =
    (_  -> 1)

    S(::, A) =
    (_ _     []    -> 2)
    (_ (_ :: _)   _ :: _  -> 3)

    D(A) =
    ()

    C(xs ys, A) =
    Switch (xs, [] : A₀; "::" : A₁)

    A₀ = C(ys, S([], A)) = C(ys, (_ -> 1)) =
    Leaf 1

    A₁ = C(xs.0 xs.1 ys, ((_ _   []    -> 2) (_ _ _ :: _  -> 3))) =
    A₁ = Swap₃ (C(ys xs.0 xs.1, (([] _ _    -> 2) (_ :: _ _ _   -> 3))) =
    A₁ = Swap₃ (Switch (ys, [] : Leaf 2; "::" : Leaf 3))

    Switch (xs,
            [] : Leaf 1,
            "::" : Swap3 (Switch (ys, [] : Leaf 2, "::" : Leaf 3))

*** Les pattern-matchings comme des matrices de patterns.
*** Matrice spécialisée S(K, A) et matrice des résidus D(A)
*** Arbres de décision:
      T ::= Leaf k | Fail | Switch (o, cs) | Swap i
      cs := K₁ : T₁ ; ... ; Kₙ : Tₙ ; (default : T_d)?
*** Occurrences:
      o ::= x | o.n
*** Compilation vers les arbres de décisions

   C (o₁ ... oₙ, A)?

   C (o₁ ... oₙ, ∅) = Fail
   C (o₁ ... oₙ, ( ( _ ... _ ) ... )) = Leaf a1

   Sinon, il existe au moins une colonne qui contient
   un pattern qui n'est pas un wildcard. Soit i, le
   numéro d'une telle colonne.

   Supposons que i = 1: Calculer tous les constructeurs { c₁, .., cₖ }
   qui apparaissent dans la colonne i.

   Ensuite, pour chaque cₖ d'arité m:
   Aₖ = C (o₁ · 1 ... o₁ · m o₂ ⋯ oₙ, S (cₖ, A))

   Si les cₖ couvrent tous les cas possibles alors
   C (o₁ ... oₙ, A) = Switch (o₁, K₁ : A₁ … Kₖ : Aₖ)

   Si les cₖ ne couvrent pas tous les cas possibles alors
   A_D = C (o₂ ⋯ oₙ, D (A))
   C (o₁ ... oₙ, A) = Switch (o₁, K₁ : A₁ … Kₖ : Aₖ; default: A_D)

   Si i > 1, alors on permute les occurrences i et 1 (o') ainsi que
   les colonnes i et 1 de la matrice (A') puis:

   C (o₁ ... oₙ, A) = Swapᵢ (C (o', A'))

** DONE Compilation des fonctions de première classe
*** Rappel sur la notion de fermeture
Hobix:

val m :=
  val x := 1;
  \ y => x + y.

val z := m 42.

Fopix:

def f_code (env, y) = env[1] + y

val m =
  val x = 1;
  val b = alloc_block 2;
  b[0] = f_code;
  b[1] = x;
  b

val z =
  val f = alloc_read m 0;
  f (m, 42)

*** Les différents choix de représentation
*** Le langage fopix
*** La compilation par explicitation des fermetures
* Cours du <2016-02-24>
** DONE Répondre aux questions floues.
** DONE Fopix
** DONE Explicitation des fermetures unaires
** TODO Optimisations
** TODO Traitement des fermetures n-naires
* Cours du <2016-03-02>
** DONE Questions sur le jalon 4
*** Quelle est le rôle de la fonction pattern?
   Si on a :
   type t := { A : int | B }.

   expression << y ? { A x -> x | B -> 2 | _ -> 3 } >> =

   if read_block y 0 = 0 then
     val x = read_block y 1;
     x
   else if read_block y 0 = 1 then
     2
   else
     3

   pattern << y >> << A x >> =
   (<< read_block y 0 = 0 >>, [(x, << read_block y 1 >>])

   pattern << y >> << B >> =
   (<< read_block y 0 = 1 >>, [])

   if read_block x 0 = 0 then
     1
   else
     2

** DONE Questions sur l'explicitation des fermetures
*** Comment compiler les fonctions mutuellement récursives?

rec f x := g x
and g x := f x.

donne en Fopix:

def f x env := env[1][0] x env[1].
def g x env := env[1][0] x env[1].

val fc := allocate_block 2;
val gc := allocate_block 2;
write_block fc 0 &f;
write_block fc 1 gc;
write_block gc 0 &g;
write_block gc 1 fc.

** DONE Optimisations
*** Optimisation des appels internes
En Hopix:

rec fact n := if n = 0 then 1 else n * fact (n - 1) fi
val y := fact 2.

Si on la compile naivement:

def ffact n env =
  if n = 0 then
    1
  else
    n * env[1][0] (n - 1) env[1]
  fi

val fact :=
   val b := allocate_block 2;
   b[0] <- &ffact;
   b[1] <- b;
   b

val y := fact[0] 2 fact.

On veut plutôt la compiler comme suit:

def ffact n env =
  if n = 0 then
    1
  else
    n * ffact (n - 1) env
  fi

val fact :=
   val b := allocate_block 1;
   b[0] <- &ffact;
   b

val y := fact[0] 2 fact.

*** Reconnaître les appels à des fonctions connues

Dans l'exemple précédent, l'appel à la fonction fact est en fait un
FunCall et non un UnknownFunCall. En général, on peut écrire un
algorithme d'évaluation symbolique de programme qui s'assure qu'un
programme Fopix écrit en Hopix se compile en le même programme Fopix.

** DONE Traitement des fermetures n-naires

*** Le problème

val f := \x => \y => x + y.
val y := f 0 1.

est compilé en Fopix comme suit:

def f1 x env :=
  let b := allocate_block 2;
  b[0] <- &f2;
  b[1] <- x;
  b

def f2 y env :=
  env[1] + y

val f :=
  let b := allocate_block 1;
  b[0] <- &f1;
  b

val y :=
   let app1 := f[0] 0 f;
   app1[0] 1 app1

On aimerait plutôt compiler ce programme en:

def f1 x y env :=
  x + y

val f :=
  let b := allocate_block 4;
  b[0] <- &f1;
  b[1] <- 2
  b

val y :=
  f1 0 1 f 

Supposons qu'en Hopix, on ait l'application partielle suivante:

val g := f 0
val z := g 1

Elle sera compilée comme suit:

val g :=
  let b := copy f;
  f[1] <- 1;
  f[2] <- 0;
  b

val z :=
  generic_apply g [1]

où

generic_apply c [v1; ...; vN] =
  val M := c[1];
  if N = M then
    c[0] c[2] ... c[K] v1 ... vN c
  else if N < M then
    let b := copy c;
    b[1] <- M - N;
    b[K + 1] <- v1;
    ...
    b[K + N] <- vN;
    b
  else if N > M then
    val c' := c[0] c[2] ... c[K] v1 ... vM c;
    generic_apply c' [vM + 1; ..; VN]
  fi

** DONE Retrolix
*** Présentation de l'AST de Retrolix
*** Compilation de Fopix vers Retrolix
**** Compilation des expressions arithmétiques
val y := 42
val x := 3 * y + 42

y <- load 42
z <- mul 3 y
x <- add z 42
**** Compilation d'une conditionnelle

val y := if 1 < 0 then 0 else 1 fi

l_cond:
   jumpif less_than 1 0 -> l_then, l_else
l_then:
   y <- 0
   jump l_cont
l_else:
   y <- 1
   jump l_cont
l_cont:
   ...
* Cours du <2016-03-16>
** TODO Présentation de MIPS
*** Survol de la spécification
*** Les registres

*** Tour des opcodes
*** Enregistrement d'activation
*** Mars
*** Qemu-MIPS + GCC
*** Convention d'appels des fonctions sur Linux-MIPS32-GCC ABI
** TODO Analyse de vivacité dans Retrolix
*** Remarques préliminaires

    x <- ...      x est définie par l'instruction.

    . <- .x.      x est utilisée par l'instruction.

*** Graphe de flot de contrôle
*** Notion d'analyse statique
*** Analyse de vivacité
**** Définition
     Une variable a est vivante si sa valeur est utilisée dans la suite du
     calcul.

     Vivacité dynamique: une variable a est dynamiquement vivante en n si
     il existe une exécution du programme à partir de n vers un usage de a
     qui ne passe par aucune définition de a.

     Vivacité statique: Une variable a est statiquement vivante en n
     s'il existe un chemin dans le graphe de flot de contrôle de n vers
     un usage de a qui ne passe par aucune définition de a.

**** Calcul
    in(n)  = use(n) ∪ (out(n) ∖ def(n))
    out(n) = ⋃ₛ in(s)   for s in successors (n)

    in_{n+1}(n)  = use_n(n) ∪ (out_n(n) ∖ def_n(n))
    out_{n+1}(n) = ⋃ₛ in_n(s)   for s in successors (n)

    Faire tourner l'algorithme sur le programme suivant:

    live-in: ?
    g <- load [j + 12]
    h <- k - 1
    f <- g * h
    e <- load [j + 8]
    m <- load [j + 16]
    b <- load f
    c <- e + 8
    d <- c
    k <- m + 4
    j <- b
    live-out: d k j

*** Allocation de registre par coloration de graphe
**** Graphe d'interférence

     Pour chaque instruction:
     Si a est définie par l'instruction et que b est vivante en sortie
     alors a et b sont en interférence.

**** Algorithme naïf de coloration

     Faire tourner l'algorithme récursif.
* Cours du <2016-03-23>
** De GOTO a Call/CC
** Retour sur l'analyse de vivacité
* Cours du <2016-03-30>
** Coloriage de graphe naïf
   L'algorithme en pseudo-code

   spilled variable = variable en pile.

   colorize G colors =
     Pick a node in G which degree < |colors|.
     There are two cases:
     - G is empty => an empty coloring is fine.
     - there is a node n which degree < |colors| otherwise there is "some" node n
       let coloring = colorize (G \ { n }) colors in
       let remaining_colors = colors \ colors_of (neighbours(n)) in coloring in
       if remaining_colors = ∅ then
         mark n as spilled
       else
         return (coloring ∪ { n ↦ pick_color in remaining_colors })

** Retour sur les conventions d'appel
*** Le module MipsArch
    - Lire MipsArch
*** Modification de la compilation FopixToRetrolix
    - Passage des arguments et du retour.
    - Sauvegarde/Restaurations des registres.
*** Modification de l'analyse de vivacité
    - Les registres définis par les appels de fonctions
*** Modification du coloriage de graphe naïf
    - Utilisation d'un graphe précolorié

** Coloriage d'un graphe avec relation de préférence
*** Fusion de deux nœuds
*** Deux heuristiques
**** Briggs

     - Si en fusionnant a et b dans G, le nombre de noeuds voisins du
       nouveau noeud qui ne sont pas simplifiables est strictement
       inferieur au nombre de couleurs disponibles alors OK.

**** George

     - Si les noeuds non simplifiables et en conflit avec a sont des
       noeuds qui etaient aussi en conflit avec b (ou inversement)
       alors OK.

**** Justifications informelles

     Pourquoi si G était k-coloriable alors après fusion G est encore
     k-coloriable?

***** Briggs

      Après avoir simplifié tous les noeuds adjacents du noeud fusionné,
      il va en rester un nombre strictement inférieur à k donc le noeud
      fusionné sera simplifiable et donc si le graphe sans ce noeud était
      k-coloriable, il sera encore k-coloriable.

***** George

      Soit S l'ensemble des noeuds simplifiables adjacents à "a".

      Si on simplifie S dans G - sans faire la fusion - on obtient
      un graphe G₁.

      Si on simplifie S dans G après fusion, on obtient un graphe
      G₂ qui est un sous-graphe de G₁.

      G₂ est au moins aussi facile à colorier que G₁.

*** Nouvel algorithme
   colorize G colors =
     Pick a node in G which degree < |colors| and with no preference relation.
     There are four cases:
     - G is empty => an empty coloring is fine.
     - there is a node n which degree < |colors|
       let coloring = colorize (G \ { n }) colors in
       let remaining_colors = colors \ colors_of (neighbours(n)) in coloring in
       if remaining_colors = ∅ then
         mark n as spilled
       else
         return (coloring ∪ { n ↦ pick_color in remaining_colors })
     - there are two nodes a and b that love each other.
       if briggs or georges give their blessing then
         colorize (coalesce a b in G) colors
       else
         colorize (remove preference between a b in G) colors
     - otherwise, there is some node n and try optimistic simplification.
*** Design de l'interface du module de Graph

* Cours du <2016-04-06>
** Retour sur la structure de graphe
** Retour sur l'algorithme avec fusion
** De Retrolix à MIPS
* Cours du <2016-04-13>
** Traduction vers MIPS
** Déssassembler
** Value numbering
