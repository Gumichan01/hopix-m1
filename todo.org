* Préparation des cours et des TPs
** Semaine du 21/09/2015
*** TODO S'inscrire sur la liste de diffusion du cours.
** Semaine du 28/09/2015
*** TODO Avant le TP : Lire la documentation d'ocamllex et menhir.
*** TODO Lire marthe.ml

* Cours du <2016-02-10>
** TODO Introduire hobix
** TODO Compilation naïve
* Cours du <2016-02-17>
** DONE La beauté des monades, encore une fois.
** DONE Compilation avec arbres de décision
*** Prendre l'exemple de merge.

    type t = P of int * int

    let rec merge xs ys = match (xs, ys) with
    | [], _ -> .. 
    | _, [] -> ..
    | x :: xs, y :: ys -> ...            

    A =
    ([]           _     -> 1)
    (_            []    -> 2)
    ("_ :: (_ :: _)"  "_ :: _"  -> 3)

    S([], A) =
    (_  -> 1)

    S(::, A) =
    (_ _     []    -> 2)
    (_ (_ :: _)   _ :: _  -> 3)

    D(A) =
    ()

    C(xs ys, A) =
    Switch (xs, [] : A₀; "::" : A₁)

    A₀ = C(ys, S([], A)) = C(ys, (_ -> 1)) =
    Leaf 1

    A₁ = C(xs.0 xs.1 ys, ((_ _   []    -> 2) (_ _ _ :: _  -> 3))) =
    A₁ = Swap₃ (C(ys xs.0 xs.1, (([] _ _    -> 2) (_ :: _ _ _   -> 3))) =
    A₁ = Swap₃ (Switch (ys, [] : Leaf 2; "::" : Leaf 3))

    Switch (xs,
            [] : Leaf 1,
            "::" : Swap3 (Switch (ys, [] : Leaf 2, "::" : Leaf 3))

*** Les pattern-matchings comme des matrices de patterns.
*** Matrice spécialisée S(K, A) et matrice des résidus D(A)
*** Arbres de décision:
      T ::= Leaf k | Fail | Switch (o, cs) | Swap i
      cs := K₁ : T₁ ; ... ; Kₙ : Tₙ ; (default : T_d)?
*** Occurrences:
      o ::= x | o.n
*** Compilation vers les arbres de décisions

   C (o₁ ... oₙ, A)?

   C (o₁ ... oₙ, ∅) = Fail
   C (o₁ ... oₙ, ( ( _ ... _ ) ... )) = Leaf a1

   Sinon, il existe au moins une colonne qui contient
   un pattern qui n'est pas un wildcard. Soit i, le
   numéro d'une telle colonne.

   Supposons que i = 1: Calculer tous les constructeurs { c₁, .., cₖ }
   qui apparaissent dans la colonne i.

   Ensuite, pour chaque cₖ d'arité m:
   Aₖ = C (o₁ · 1 ... o₁ · m o₂ ⋯ oₙ, S (cₖ, A))

   Si les cₖ couvrent tous les cas possibles alors
   C (o₁ ... oₙ, A) = Switch (o₁, K₁ : A₁ … Kₖ : Aₖ)

   Si les cₖ ne couvrent pas tous les cas possibles alors
   A_D = C (o₂ ⋯ oₙ, D (A))
   C (o₁ ... oₙ, A) = Switch (o₁, K₁ : A₁ … Kₖ : Aₖ; default: A_D)

   Si i > 1, alors on permute les occurrences i et 1 (o') ainsi que
   les colonnes i et 1 de la matrice (A') puis:

   C (o₁ ... oₙ, A) = Swapᵢ (C (o', A'))

** TODO Compilation des fonctions de première classe
*** Rappel sur la notion de fermeture
Hobix:

val m :=
  val x := 1;
  \ y => x + y.

val z := m 42.

Fopix:

def f_code (env, y) = env[1] + y

val m =
  val x = 1;
  val b = alloc_block 2;
  b[0] = f_code;
  b[1] = x;
  b

val z =
  val f = alloc_read m 0;
  f (m, 42)

*** Les différents choix de représentation
*** Le langage fopix
*** La compilation par explicitation des fermetures
