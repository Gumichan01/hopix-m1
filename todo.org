* Préparation des cours et des TPs
** Semaine du 21/09/2015
*** TODO S'inscrire sur la liste de diffusion du cours.
** Semaine du 28/09/2015
*** TODO Avant le TP : Lire la documentation d'ocamllex et menhir.
*** TODO Lire marthe.ml

* Cours du <2016-02-10>
** TODO Introduire hobix
** TODO Compilation naïve
* Cours du <2016-02-17>
** DONE La beauté des monades, encore une fois.
** DONE Compilation avec arbres de décision
*** Prendre l'exemple de merge.

    type t = P of int * int

    let rec merge xs ys = match (xs, ys) with
    | [], _ -> .. 
    | _, [] -> ..
    | x :: xs, y :: ys -> ...            

    A =
    ([]           _     -> 1)
    (_            []    -> 2)
    ("_ :: (_ :: _)"  "_ :: _"  -> 3)

    S([], A) =
    (_  -> 1)

    S(::, A) =
    (_ _     []    -> 2)
    (_ (_ :: _)   _ :: _  -> 3)

    D(A) =
    ()

    C(xs ys, A) =
    Switch (xs, [] : A₀; "::" : A₁)

    A₀ = C(ys, S([], A)) = C(ys, (_ -> 1)) =
    Leaf 1

    A₁ = C(xs.0 xs.1 ys, ((_ _   []    -> 2) (_ _ _ :: _  -> 3))) =
    A₁ = Swap₃ (C(ys xs.0 xs.1, (([] _ _    -> 2) (_ :: _ _ _   -> 3))) =
    A₁ = Swap₃ (Switch (ys, [] : Leaf 2; "::" : Leaf 3))

    Switch (xs,
            [] : Leaf 1,
            "::" : Swap3 (Switch (ys, [] : Leaf 2, "::" : Leaf 3))

*** Les pattern-matchings comme des matrices de patterns.
*** Matrice spécialisée S(K, A) et matrice des résidus D(A)
*** Arbres de décision:
      T ::= Leaf k | Fail | Switch (o, cs) | Swap i
      cs := K₁ : T₁ ; ... ; Kₙ : Tₙ ; (default : T_d)?
*** Occurrences:
      o ::= x | o.n
*** Compilation vers les arbres de décisions

   C (o₁ ... oₙ, A)?

   C (o₁ ... oₙ, ∅) = Fail
   C (o₁ ... oₙ, ( ( _ ... _ ) ... )) = Leaf a1

   Sinon, il existe au moins une colonne qui contient
   un pattern qui n'est pas un wildcard. Soit i, le
   numéro d'une telle colonne.

   Supposons que i = 1: Calculer tous les constructeurs { c₁, .., cₖ }
   qui apparaissent dans la colonne i.

   Ensuite, pour chaque cₖ d'arité m:
   Aₖ = C (o₁ · 1 ... o₁ · m o₂ ⋯ oₙ, S (cₖ, A))

   Si les cₖ couvrent tous les cas possibles alors
   C (o₁ ... oₙ, A) = Switch (o₁, K₁ : A₁ … Kₖ : Aₖ)

   Si les cₖ ne couvrent pas tous les cas possibles alors
   A_D = C (o₂ ⋯ oₙ, D (A))
   C (o₁ ... oₙ, A) = Switch (o₁, K₁ : A₁ … Kₖ : Aₖ; default: A_D)

   Si i > 1, alors on permute les occurrences i et 1 (o') ainsi que
   les colonnes i et 1 de la matrice (A') puis:

   C (o₁ ... oₙ, A) = Swapᵢ (C (o', A'))

** DONE Compilation des fonctions de première classe
*** Rappel sur la notion de fermeture
Hobix:

val m :=
  val x := 1;
  \ y => x + y.

val z := m 42.

Fopix:

def f_code (env, y) = env[1] + y

val m =
  val x = 1;
  val b = alloc_block 2;
  b[0] = f_code;
  b[1] = x;
  b

val z =
  val f = alloc_read m 0;
  f (m, 42)

*** Les différents choix de représentation
*** Le langage fopix
*** La compilation par explicitation des fermetures
* Cours du <2016-02-24>
** DONE Répondre aux questions floues.
** DONE Fopix
** DONE Explicitation des fermetures unaires
** TODO Optimisations
** TODO Traitement des fermetures n-naires
* Cours du <2016-03-02>
** DONE Questions sur le jalon 4
*** Quelle est le rôle de la fonction pattern?
   Si on a :
   type t := { A : int | B }.

   expression << y ? { A x -> x | B -> 2 | _ -> 3 } >> =

   if read_block y 0 = 0 then
     val x = read_block y 1;
     x
   else if read_block y 0 = 1 then
     2
   else
     3

   pattern << y >> << A x >> =
   (<< read_block y 0 = 0 >>, [(x, << read_block y 1 >>])

   pattern << y >> << B >> =
   (<< read_block y 0 = 1 >>, [])

   if read_block x 0 = 0 then
     1
   else
     2

** DONE Questions sur l'explicitation des fermetures
*** Comment compiler les fonctions mutuellement récursives?

rec f x := g x
and g x := f x.

donne en Fopix:

def f x env := env[1][0] x env[1].
def g x env := env[1][0] x env[1].

val fc := allocate_block 2;
val gc := allocate_block 2;
write_block fc 0 &f;
write_block fc 1 gc;
write_block gc 0 &g;
write_block gc 1 fc.

** DONE Optimisations
*** Optimisation des appels internes
En Hopix:

rec fact n := if n = 0 then 1 else n * fact (n - 1) fi
val y := fact 2.

Si on la compile naivement:

def ffact n env =
  if n = 0 then
    1
  else
    n * env[1][0] (n - 1) env[1]
  fi

val fact :=
   val b := allocate_block 2;
   b[0] <- &ffact;
   b[1] <- b;
   b

val y := fact[0] 2 fact.

On veut plutôt la compiler comme suit:

def ffact n env =
  if n = 0 then
    1
  else
    n * ffact (n - 1) env
  fi

val fact :=
   val b := allocate_block 1;
   b[0] <- &ffact;
   b

val y := fact[0] 2 fact.

*** Reconnaître les appels à des fonctions connues

Dans l'exemple précédent, l'appel à la fonction fact est en fait un
FunCall et non un UnknownFunCall. En général, on peut écrire un
algorithme d'évaluation symbolique de programme qui s'assure qu'un
programme Fopix écrit en Hopix se compile en le même programme Fopix.

** DONE Traitement des fermetures n-naires

*** Le problème

val f := \x => \y => x + y.
val y := f 0 1.

est compilé en Fopix comme suit:

def f1 x env :=
  let b := allocate_block 2;
  b[0] <- &f2;
  b[1] <- x;
  b

def f2 y env :=
  env[1] + y

val f :=
  let b := allocate_block 1;
  b[0] <- &f1;
  b

val y :=
   let app1 := f[0] 0 f;
   app1[0] 1 app1

On aimerait plutôt compiler ce programme en:

def f1 x y env :=
  x + y

val f :=
  let b := allocate_block 4;
  b[0] <- &f1;
  b[1] <- 2
  b

val y :=
  f1 0 1 f 

Supposons qu'en Hopix, on ait l'application partielle suivante:

val g := f 0
val z := g 1

Elle sera compilée comme suit:

val g :=
  let b := copy f;
  f[1] <- 1;
  f[2] <- 0;
  b

val z :=
  generic_apply g [1]

où

generic_apply c [v1; ...; vN] =
  val M := c[1];
  if N = M then
    c[0] c[2] ... c[K] v1 ... vN c
  else if N < M then
    let b := copy c;
    b[1] <- M - N;
    b[K + 1] <- v1;
    ...
    b[K + N] <- vN;
    b
  else if N > M then
    val c' := c[0] c[2] ... c[K] v1 ... vM c;
    generic_apply c' [vM + 1; ..; VN]
  fi

** DONE Retrolix
*** Présentation de l'AST de Retrolix
*** Compilation de Fopix vers Retrolix
**** Compilation des expressions arithmétiques
val y := 42
val x := 3 * y + 42

y <- load 42
z <- mul 3 y
x <- add z 42
**** Compilation d'une conditionnelle

val y := if 1 < 0 then 0 else 1 fi

l_cond:
   jumpif less_than 1 0 -> l_then, l_else
l_then:
   y <- 0
   jump l_cont
l_else:
   y <- 1
   jump l_cont
l_cont:
   ...
* Cours du <2016-03-16>
** TODO Présentation de MIPS
** TODO Analyse de vivacité dans Retrolix
*** Remarques préliminaires

    x <- ...      x est définie par l'instruction.

    . <- .x.      x est utilisée par l'instruction.

*** Graphe de flot de contrôle
*** Notion d'analyse statique
*** Analyse de vivacité
**** Définition
     Une variable a est vivante si sa valeur est utilisée dans la suite du
     calcul.

     Vivacité dynamique: une variable a est dynamiquement vivante en n si
     il existe une exécution du programme à partir de n vers un usage de a
     qui ne passe par aucune définition de a.

     Vivacité statique: Une variable a est statiquement vivante s'il existe
     existe un chemin dans le graphe de flot de contrôle qui ne passe par
     aucune définition de a.

**** Calcul
    in(n)  = use(n) ∪ (out(n) ∖ def(n))
    out(n) = ⋃ₛ in(s)   for s in successors (n)

    Faire tourner l'algorithme sur le programme suivant:

    live-in: ?
    g <- load [j + 12]
    h <- k - 1
    f <- g * h
    e <- load [j + 8]
    m <- load [j + 16]
    b <- load f
    c <- e + 8
    d <- c
    k <- m + 4
    j <- b
    live-out: d k j

*** Allocation de registre par coloration de graphe
**** Graphe d'interférence

     Pour chaque instruction:
     Si a est définie par l'instruction et que b est vivante en sortie
     alors a et b sont en interférence.

**** Algorithme naïf de coloration

     Faire tourner l'algorithme récursif.
